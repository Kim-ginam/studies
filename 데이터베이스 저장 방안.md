# MSA 환경에서 데이터베이스 저장 방안

여러 개의 **파드가 동일한 데이터베이스에 접근**하여 데이터를 수정, 삽입, 삭제해야 하는 경우, **데이터 일관성**과 **경합 관리**가 중요한 문제로 다가옵니다. 이러한 상황에서는 다음과 같은 방법을 사용할 수 있습니다:

### 1. 동시성 제어 (Concurrency Control)
여러 파드가 동시에 같은 데이터에 접근하거나 수정할 때, **데이터의 일관성**을 보장하기 위해 **낙관적 락(Optimistic Locking)** 또는 **비관적 락(Pessimistic Locking)** 같은 동시성 제어 방법을 사용할 수 있습니다.

#### 1.1 낙관적 락 (Optimistic Locking)
- **낙관적 락**은 데이터에 접근할 때 충돌이 발생하지 않을 것으로 가정하고 처리하지만, 데이터를 커밋하려는 시점에 충돌을 확인하는 방식입니다.
- 각 레코드에 **버전 필드**를 추가하고, 데이터가 수정될 때마다 버전을 증가시켜 최신 버전만 업데이트할 수 있도록 합니다.
- 이를 통해 파드들이 동시에 데이터를 업데이트할 때, 먼저 읽고 커밋한 트랜잭션만 허용하고 나머지는 **실패 처리**하여 재시도를 요청하게 됩니다.

예시 코드 (JPA 사용):
```java
@Entity
public class Order {
    @Id
    @GeneratedValue
    private Long orderId;

    @Version
    private Long version; // 낙관적 락을 위한 버전 필드

    private String orderStatus;

    // Getters and Setters
}
```
- **버전 필드**는 데이터베이스에 삽입, 수정 시 일관성을 유지하도록 보장합니다.

#### 1.2 비관적 락 (Pessimistic Locking)
- **비관적 락**은 트랜잭션이 데이터에 접근할 때 다른 트랜잭션이 동일 데이터에 접근하지 못하도록 **락을 걸어** 데이터의 일관성을 보장합니다.
- 데이터베이스 수준에서 락을 걸기 때문에, **동시성 문제를 완전히 차단**할 수 있지만, **성능 저하**가 발생할 수 있습니다.

예시 코드 (JPA 사용):
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
public Order findOrderWithLock(Long orderId) {
    return entityManager.find(Order.class, orderId);
}
```
- 여러 파드가 동일 데이터를 동시에 수정하려 할 경우, 비관적 락을 사용해 다른 트랜잭션의 접근을 차단합니다.

- **데이터를 읽고 수정**하는 작업이 순차적으로 이어지는 경우:
파드 A가 특정 주문(orderId)을 읽고, 그 값을 기반으로 수정하려고 하는 사이에 파드 B가 동일한 데이터를 읽고 다른 수정 작업을 진행할 수 있습니다. 이때 **비관적 락**을 사용하면, 파드 A가 데이터를 읽고 수정할 때까지 다른 트랜잭션의 접근을 차단할 수 있습니다.

- **여러 트랜잭션이 동일한 데이터에 접근할 때 발생하는 경합 문제:**
만약 여러 트랜잭션이 **동시에 같은 데이터를 조회하고 나서 수정하려는 의도**가 있다면, 이를 **명시적으로 차단하기 위해 비관적 락을 사용**하는 것이 좋습니다.

### 2. 분산 락 (Distributed Lock)
여러 파드가 동일한 데이터베이스를 사용할 때, **동시성 문제**를 해결하기 위해 **분산 락**을 사용하는 것도 좋은 방법입니다. **Redis**나 **ZooKeeper**와 같은 외부 락 관리 시스템을 사용해 **락을 획득**한 파드만 데이터베이스에 접근할 수 있도록 합니다.

- **Redis를 이용한 분산 락**: **Redisson**과 같은 라이브러리를 이용해 Redis에서 락을 관리하고, 락을 획득한 파드만 데이터베이스에 접근하도록 합니다.

예시 코드 (Redisson 사용):
```java
RLock lock = redissonClient.getLock("order_lock");
try {
    lock.lock();  // 락 획득
    // 데이터베이스 수정 작업
} finally {
    lock.unlock();  // 락 해제
}
```
- **분산 락**은 여러 파드가 동시에 데이터에 접근할 수 없도록 보장하여, **데이터의 일관성**을 유지할 수 있습니다.

### 3. 데이터 일관성 유지 방안
#### 3.1 트랜잭션 전파 (Transactional Propagation)
**Spring @Transactional**을 사용하여 트랜잭션을 정의하고, 데이터의 삽입, 수정, 삭제 작업을 **원자적(Atomic)**으로 처리합니다. 만약 트랜잭션 내의 어떤 작업에서 실패하면, 전체 작업이 롤백되어 데이터베이스의 일관성이 보장됩니다.

- **Propagation.REQUIRED**: 기존 트랜잭션이 있으면 이를 사용하고, 없으면 새로운 트랜잭션을 시작합니다.
- **Propagation.REQUIRES_NEW**: 항상 새로운 트랜잭션을 생성합니다.

예시 코드:
```java
@Transactional(propagation = Propagation.REQUIRED)
public void createOrder(Order order) {
    orderRepository.save(order);
    // 만약 여기서 오류가 발생하면 트랜잭션이 롤백됩니다.
}
```
#### 동일한 서비스 내 파드들이 하나의 데이터베이스를 공유하는 경우
**동일한 서비스의 여러 파드**가 **하나의 데이터베이스**에 접근하는 상황에서는 @Transactional을 사용할 수 있습니다. 이 경우, 데이터베이스가 단일 인스턴스이므로 트랜잭션 매니저가 데이터베이스 내에서 트랜잭션을 관리할 수 있습니다.

 - **각 파드가 동일한 데이터베이스 인스턴스에 접근:** 여러 파드가 동일한 서비스의 복제본이므로, @Transactional을 사용해 트랜잭션을 관리할 때 데이터베이스에서 트랜잭션 일관성을 보장할 수 있습니다.
 - **단일 데이터베이스 내에서 트랜잭션 관리:** @Transactional을 사용하면, 데이터베이스 레벨에서 트랜잭션이 시작되고, 커밋 또는 롤백이 발생하므로, 모든 파드에서 동일한 데이터베이스 일관성을 유지할 수 있습니다.

### 4. 데이터 파티셔닝 (Database Sharding)
만약 **데이터베이스 부하**가 많거나 **경합 문제**가 심각하다면, 데이터를 특정 기준으로 **파티셔닝**하여 여러 데이터베이스에 분산 저장하는 것도 고려할 수 있습니다.

- 예를 들어, **고객 ID** 또는 **주문 ID**를 기준으로 데이터를 여러 데이터베이스로 나누어 저장합니다. 이렇게 하면 특정 파드가 특정 파티션에만 접근하도록 하여 **데이터베이스 경합**을 줄일 수 있습니다.

### 5. CQRS 패턴 적용
**CQRS(Command Query Responsibility Segregation)** 패턴을 사용해 **쓰기 작업**과 **읽기 작업**을 분리할 수 있습니다. 파드가 데이터베이스에 **쓰기 작업**을 수행할 때는 트랜잭션과 락을 적용하고, **읽기 작업**은 **읽기 전용 데이터베이스**에서 처리하도록 하여 성능을 최적화할 수 있습니다.

- **읽기 전용 레플리카**를 사용하여, 여러 파드가 동시에 읽기를 할 때는 **레플리카**를 활용하고, 쓰기 작업은 **마스터 데이터베이스**에만 수행하도록 합니다.

### 요약
- **낙관적 락**: 충돌 가능성이 낮은 경우 유용하며, 실패 시 버전을 비교하여 트랜잭션을 재시도합니다.
- **비관적 락**: 데이터베이스에서 락을 걸어 **충돌을 완전히 방지**하지만, **성능 저하**의 문제가 있을 수 있습니다.
- **분산 락**: Redis 등 외부 락 시스템을 사용해 여러 파드 간 **동시성 문제**를 해결할 수 있습니다.
- **트랜잭션 전파 설정**: `@Transactional`을 사용하여 데이터베이스 삽입, 수정, 삭제를 원자적으로 처리합니다.
- **데이터 파티셔닝**과 **CQRS** 패턴: 데이터베이스 경합을 줄이고 성능을 최적화하는 데 도움이 됩니다.

여러 파드가 하나의 데이터베이스에 접근하는 경우, **데이터의 일관성**과 **경합 관리**가 중요하며, 위에서 설명한 다양한 방법을 상황에 맞게 조합하여 사용할 수 있습니다. 특히, **데이터 충돌 가능성**과 **서비스의 성능 요구사항**을 고려하여 적절한 방법을 선택하는 것이 중요합니다.

### 결론
정적인 해결책**으로 **`@Transactional`**과 **락**을 사용하는 것이 동시성 문제를 해결하는 가장 현실적인 접근일 수 있습니다.

- **`@Transactional`**을 사용하여 데이터베이스 작업을 **트랜잭션으로 묶어** 일관성을 보장합니다.
- **비관적 락 (`PESSIMISTIC_WRITE`)**을 활용하여 동일한 데이터에 대한 **동시 접근을 방지**하고, 파드 간의 **경합 문제**를 피할 수 있습니다.

- 데이터베이스 자체의 기본 락은 INSERT, UPDATE, DELETE 시에 자동으로 걸리기 때문에 간단한 수정 작업에는 충분할 수 있습니다.

- 다수의 트랜잭션이 같은 데이터를 읽고 수정하는 상황에서 데이터 일관성을 보장하려면, **비관적 락 (@Lock(LockModeType.PESSIMISTIC_WRITE))**이 필요할 수 있습니다.

이렇게 하면 **불필요한 복잡성** 없이 서비스가 안정적으로 작동할 수 있고, 데이터 일관성 문제도 효과적으로 해결됩니다. 복잡한 분산 트랜잭션이나 여러 Kafka 토픽, 커넥터 설정을 관리하는 부담이 줄어들게 되죠. 

그래서 필요 이상의 복잡함을 추가하지 않고, 현재 상황에서 **간단하고 확실한 방법**을 선택하는 게 합리적입니다. 이해합니다—어려운 문제를 최대한 간결하게 해결하는 게 중요하니까요!